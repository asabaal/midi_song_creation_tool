/**\n * Music Theory module for MIDI Song Creation Tool\n * Provides core music theory functionality for scales, chords, and harmony\n */\n\n// Note mapping for conversions\nconst NOTE_NAMES = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];\nconst NOTE_ALIASES = {\n  Db: 'C#',\n  Eb: 'D#',\n  Gb: 'F#',\n  Ab: 'G#',\n  Bb: 'A#',\n};\n\n// Scale definitions (semitone intervals)\nconst SCALES = {\n  major: [0, 2, 4, 5, 7, 9, 11],\n  minor: [0, 2, 3, 5, 7, 8, 10],\n  harmonicMinor: [0, 2, 3, 5, 7, 8, 11],\n  melodicMinor: [0, 2, 3, 5, 7, 9, 11],\n  pentatonicMajor: [0, 2, 4, 7, 9],\n  pentatonicMinor: [0, 3, 5, 7, 10],\n  blues: [0, 3, 5, 6, 7, 10],\n  dorian: [0, 2, 3, 5, 7, 9, 10],\n  phrygian: [0, 1, 3, 5, 7, 8, 10],\n  lydian: [0, 2, 4, 6, 7, 9, 11],\n  mixolydian: [0, 2, 4, 5, 7, 9, 10],\n  locrian: [0, 1, 3, 5, 6, 8, 10],\n};\n\n// Chord definitions (semitone intervals from root)\nconst CHORD_TYPES = {\n  major: [0, 4, 7],\n  minor: [0, 3, 7],\n  diminished: [0, 3, 6],\n  augmented: [0, 4, 8],\n  sus2: [0, 2, 7],\n  sus4: [0, 5, 7],\n  major7: [0, 4, 7, 11],\n  minor7: [0, 3, 7, 10],\n  dominant7: [0, 4, 7, 10],\n  diminished7: [0, 3, 6, 9],\n  halfDiminished7: [0, 3, 6, 10],\n  augmented7: [0, 4, 8, 10],\n  add9: [0, 4, 7, 14],\n  add11: [0, 4, 7, 17],\n};\n\n// Roman numeral to scale degree mapping\nconst ROMAN_NUMERALS = {\n  I: 0,\n  II: 1,\n  III: 2,\n  IV: 3,\n  V: 4,\n  VI: 5,\n  VII: 6,\n  i: 0,\n  ii: 1,\n  iii: 2,\n  iv: 3,\n  v: 4,\n  vi: 5,\n  vii: 6,\n};\n\n// Fixed key signature mapping\nconst KEY_SIGNATURES = {\n  'C major': { keySignature: 0, accidental: 'sharp' },\n  'G major': { keySignature: 1, accidental: 'sharp' },\n  'D major': { keySignature: 2, accidental: 'sharp' },\n  'A major': { keySignature: 3, accidental: 'sharp' },\n  'E major': { keySignature: 4, accidental: 'sharp' },\n  'B major': { keySignature: 5, accidental: 'sharp' },\n  'F# major': { keySignature: 6, accidental: 'sharp' },\n  'C# major': { keySignature: 7, accidental: 'sharp' },\n  'F major': { keySignature: 1, accidental: 'flat' },\n  'Bb major': { keySignature: 2, accidental: 'flat' },\n  'Eb major': { keySignature: 3, accidental: 'flat' },\n  'Ab major': { keySignature: 4, accidental: 'flat' },\n  'Db major': { keySignature: 5, accidental: 'flat' },\n  'Gb major': { keySignature: 6, accidental: 'flat' },\n  'Cb major': { keySignature: 7, accidental: 'flat' },\n  'A minor': { keySignature: 0, accidental: 'sharp' },\n  'E minor': { keySignature: 1, accidental: 'sharp' },\n  'B minor': { keySignature: 2, accidental: 'sharp' },\n  'F# minor': { keySignature: 3, accidental: 'sharp' },\n  'C# minor': { keySignature: 4, accidental: 'sharp' },\n  'G# minor': { keySignature: 5, accidental: 'sharp' },\n  'D# minor': { keySignature: 6, accidental: 'sharp' },\n  'A# minor': { keySignature: 7, accidental: 'sharp' },\n  'D minor': { keySignature: 1, accidental: 'flat' },\n  'G minor': { keySignature: 2, accidental: 'flat' },\n  'C minor': { keySignature: 3, accidental: 'flat' },\n  'F minor': { keySignature: 4, accidental: 'flat' },\n  'Bb minor': { keySignature: 5, accidental: 'flat' },\n  'Eb minor': { keySignature: 6, accidental: 'flat' },\n  'Ab minor': { keySignature: 7, accidental: 'flat' },\n};\n\n/**\n * Converts a note name to MIDI note number\n * @param {string} noteName - Note name (e.g. 'C4', 'F#5')\n * @returns {number} MIDI note number\n */\nfunction noteToMidi(noteName) {\n  // Handle flat notes (convert to sharp equivalent)\n  Object.keys(NOTE_ALIASES).forEach(flat => {\n    noteName = noteName.replace(flat, NOTE_ALIASES[flat]);\n  });\n\n  // Extract note and octave\n  const note = noteName.slice(0, -1);\n  const octave = parseInt(noteName.slice(-1));\n\n  // Calculate MIDI note number\n  const noteIndex = NOTE_NAMES.indexOf(note);\n  if (noteIndex === -1) {\n    throw new Error(`Invalid note name: ${note}`);\n  }\n\n  return noteIndex + (octave + 1) * 12;\n}\n\n/**\n * Converts a MIDI note number to note name\n * @param {number} midiNote - MIDI note number\n * @returns {string} Note name (e.g. 'C4', 'F#5')\n */\nfunction midiToNote(midiNote) {\n  const octave = Math.floor(midiNote / 12) - 1;\n  const noteIndex = midiNote % 12;\n  return NOTE_NAMES[noteIndex] + octave;\n}\n\n/**\n * Generates a scale from a root note and scale type\n * @param {string} root - Root note name (e.g. 'C', 'F#')\n * @param {string} scaleType - Scale type (e.g. 'major', 'minor')\n * @param {number} octave - Starting octave number\n * @returns {number[]} Array of MIDI note numbers representing the scale\n */\nfunction generateScale(root, scaleType, octave = 4) {\n  if (!SCALES[scaleType]) {\n    throw new Error(`Unknown scale type: ${scaleType}`);\n  }\n\n  const rootNote = noteToMidi(`${root}${octave}`);\n  return SCALES[scaleType].map(interval => rootNote + interval);\n}\n\n/**\n * Generates a chord from a root note and chord type\n * @param {string} root - Root note name (e.g. 'C', 'F#')\n * @param {string} chordType - Chord type (e.g. 'major', 'minor7')\n * @param {number} octave - Starting octave number\n * @returns {number[]} Array of MIDI note numbers representing the chord\n */\nfunction generateChord(root, chordType, octave = 4) {\n  if (!CHORD_TYPES[chordType]) {\n    throw new Error(`Unknown chord type: ${chordType}`);\n  }\n\n  const rootNote = noteToMidi(`${root}${octave}`);\n  return CHORD_TYPES[chordType].map(interval => rootNote + interval);\n}\n\n/**\n * Determines the key signature (number of sharps/flats) for a given key\n * @param {string} key - Key name (e.g. 'C major', 'F# minor')\n * @returns {Object} Object with keySignature (number of sharps/flats) and accidental ('sharp' or 'flat')\n */\nfunction getKeySignature(key) {\n  if (!KEY_SIGNATURES[key]) {\n    // Circle of fifths positions (C major = 0, moving clockwise adds sharps)\n    const sharpKeys = {\n      C: 0,\n      G: 1,\n      D: 2,\n      A: 3,\n      E: 4,\n      B: 5,\n      'F#': 6,\n      'C#': 7,\n    };\n\n    const [root, mode] = key.split(' ');\n\n    // Adjust for minor keys (relative minor is 3 semitones below major)\n    let position;\n    if (mode === 'major') {\n      position = sharpKeys[root] || -sharpKeys[NOTE_ALIASES[root]];\n    } else if (mode === 'minor') {\n      // Relative major is 3 semitones above, or 9 semitones below\n      const relativeMajor = NOTE_NAMES[(NOTE_NAMES.indexOf(root) + 3) % 12];\n      position = sharpKeys[relativeMajor] || -sharpKeys[NOTE_ALIASES[relativeMajor]];\n    } else {\n      throw new Error(`Invalid mode: ${mode}`);\n    }\n\n    // Negative positions are flat keys\n    return {\n      keySignature: Math.abs(position),\n      accidental: position >= 0 ? 'sharp' : 'flat',\n    };\n  }\n\n  // Use the predefined key signature mapping\n  return KEY_SIGNATURES[key];\n}\n\n/**\n * Generates a chord progression from Roman numeral notation\n * @param {string[]} progression - Array of Roman numerals (e.g. ['I', 'IV', 'V', 'I'])\n * @param {string} key - Key name (e.g. 'C', 'F#')\n * @param {string} mode - Mode name (e.g. 'major', 'minor')\n * @param {number} octave - Starting octave\n * @returns {Array<Array<number>>} Array of chord arrays, each containing MIDI note numbers\n */\nfunction generateChordProgression(progression, key, mode, octave = 4) {\n  const scale = generateScale(key, mode, octave);\n  \n  // Make sure we have a complete scale with at least 7 notes for diatonic chords\n  const fullScale = [...scale];\n  if (fullScale.length < 7) {\n    // Add next octave if needed\n    const nextOctaveScale = generateScale(key, mode, octave + 1);\n    for (let i = fullScale.length; i < 7; i++) {\n      fullScale.push(nextOctaveScale[i - fullScale.length]);\n    }\n  }\n  \n  // For minor key, D is at position 5 from A (A, B, C, D, E) or index 3 in the scale\n  const result = progression.map(numeral => {\n    // Get scale degree from roman numeral\n    let scaleDegree = ROMAN_NUMERALS[numeral];\n    if (scaleDegree === undefined) {\n      throw new Error(`Invalid Roman numeral: ${numeral}`);\n    }\n\n    // Get root note of chord from scale degree\n    const rootNote = fullScale[scaleDegree];\n    const rootName = midiToNote(rootNote).replace(/\\d/, ''); // Remove octave number\n    const chordOctave = Math.floor(rootNote / 12) - 1;\n\n    // Determine chord type based on scale position and mode\n    let chordType;\n\n    // Adjust for major/minor chord types based on mode and position in the scale\n    if (mode === 'major') {\n      // In major keys: I, IV, V are major; ii, iii, vi are minor; vii° is diminished\n      if ([0, 3, 4].includes(scaleDegree)) {\n        chordType = 'major';\n      } else if ([1, 2, 5].includes(scaleDegree)) {\n        chordType = 'minor';\n      } else {\n        chordType = 'diminished';\n      }\n    } else if (mode === 'minor') {\n      // In minor keys: i, iv, v are minor; III, VI, VII are major; ii° is diminished\n      // Note: v could be minor or major (harmonic minor would make it major)\n      if ([2, 5, 6].includes(scaleDegree)) {\n        chordType = 'major';\n      } else if ([0, 3, 4].includes(scaleDegree)) {\n        chordType = 'minor';\n      } else {\n        chordType = 'diminished';\n      }\n    } else {\n      // Default based on numeral case if mode is not recognized\n      chordType = numeral === numeral.toUpperCase() ? 'major' : 'minor';\n    }\n\n    // Generate the chord\n    return generateChord(rootName, chordType, chordOctave);\n  });\n\n  return result;\n}\n\nmodule.exports = {\n  noteToMidi,\n  midiToNote,\n  generateScale,\n  generateChord,\n  getKeySignature,\n  generateChordProgression,\n  NOTE_NAMES,\n  SCALES,\n  CHORD_TYPES,\n};\n