<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Super Simple MIDI Player</title>
  <style>
    body { font-family: Arial, sans-serif; max-width: 1000px; margin: 0 auto; padding: 20px; }
    h1, h2 { color: #333; }
    button { background: #4CAF50; color: white; border: none; padding: 10px 15px; 
             border-radius: 4px; cursor: pointer; margin: 5px; }
    button.blue { background: #2196F3; }
    button.red { background: #F44336; }
    button.purple { background: #9C27B0; }
    button.orange { background: #FF9800; }
    button:disabled { background: #cccccc; cursor: not-allowed; }
    .card { border: 1px solid #ddd; border-radius: 4px; padding: 15px; margin-bottom: 20px; }
    .controls { display: flex; gap: 10px; margin-bottom: 10px; flex-wrap: wrap; }
    select, input { padding: 8px; border-radius: 4px; border: 1px solid #ddd; margin: 5px; }
    .control-group { display: flex; flex-direction: column; border: 1px solid #eee; 
                     padding: 10px; border-radius: 4px; margin: 10px 0; }
    .control-group h3 { margin-top: 0; font-size: 1em; }
    .pattern-controls { display: flex; gap: 10px; flex-wrap: wrap; margin-top: 10px; }
    #piano-roll { height: 400px; background: #f5f5f5; overflow: auto; position: relative; }
    .piano-key { position: absolute; height: 20px; border-bottom: 1px solid #ddd; display: flex;
                align-items: center; padding-left: 10px; font-size: 12px; width: 100px; }
    .piano-key.white { background: white; }
    .piano-key.black { background: #f8f8f8; }
    .piano-note { position: absolute; height: 18px; background: #4285f4; border-radius: 3px; opacity: 0.8; 
                 cursor: pointer; color: white; font-size: 10px; display: flex; align-items: center; 
                 justify-content: center; overflow: hidden; }
    .bassline-note { background: #0f9d58; }
    .drum-note { background: #db4437; }
    .status { padding: 10px; background: #f1f1f1; margin-top: 20px; border-radius: 4px; }
    .log { height: 100px; overflow: auto; background: #f1f1f1; padding: 10px; 
          font-family: monospace; margin-top: 10px; }
    .success { color: green; }
    .error { color: red; }
    textarea { width: 100%; height: 100px; margin-top: 10px; font-family: monospace; }
    .hidden { display: none; }
    .info-text { font-size: 0.9em; color: #666; margin: 5px 0; }
    .col-2 { display: grid; grid-template-columns: 1fr 1fr; grid-gap: 10px; }
    @media (max-width: 768px) {
      .col-2 { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <h1>Super Simple MIDI Player</h1>
  <p>Create music with just a few clicks:</p>
  
  <div class="card">
    <h2>1. Create a Session and Sequence</h2>
    <div class="controls">
      <button id="setupBtn">Set Up (Create Session + Sequence)</button>
      <span id="setupStatus">Not set up yet</span>
    </div>
  </div>
  
  <div class="card">
    <h2>2. Generate Music</h2>
    <div class="col-2">
      <!-- Random Notes Controls -->
      <div class="control-group">
        <h3>Random Notes</h3>
        <div class="pattern-controls">
          <select id="chordKey" disabled>
            <option value="C">C</option>
            <option value="C#">C#</option>
            <option value="D">D</option>
            <option value="D#">D#</option>
            <option value="E">E</option>
            <option value="F">F</option>
            <option value="F#">F#</option>
            <option value="G">G</option>
            <option value="G#">G#</option>
            <option value="A">A</option>
            <option value="A#">A#</option>
            <option value="B">B</option>
          </select>
          <select id="chordScale" disabled>
            <option value="major">Major</option>
            <option value="minor">Minor</option>
            <option value="melodic_minor">Melodic Minor</option>
            <option value="harmonic_minor">Harmonic Minor</option>
          </select>
          <select id="chordOctave" disabled>
            <option value="3">Octave 3</option>
            <option value="4" selected>Octave 4</option>
            <option value="5">Octave 5</option>
          </select>
          <input type="number" id="noteCount" min="4" max="32" value="8" disabled>
          <label for="noteCount">notes</label>
        </div>
        <button id="chordBtn" disabled>Add Random Notes</button>
      </div>
      
      <!-- Bassline Controls -->
      <div class="control-group">
        <h3>Bassline</h3>
        <div class="pattern-controls">
          <select id="bassKey" disabled>
            <option value="C">C</option>
            <option value="C#">C#</option>
            <option value="D">D</option>
            <option value="D#">D#</option>
            <option value="E">E</option>
            <option value="F">F</option>
            <option value="F#">F#</option>
            <option value="G">G</option>
            <option value="G#">G#</option>
            <option value="A">A</option>
            <option value="A#">A#</option>
            <option value="B">B</option>
          </select>
          <select id="bassScale" disabled>
            <option value="major">Major</option>
            <option value="minor">Minor</option>
            <option value="melodic_minor">Melodic Minor</option>
            <option value="harmonic_minor">Harmonic Minor</option>
          </select>
          <select id="bassOctave" disabled>
            <option value="2">Octave 2</option>
            <option value="3" selected>Octave 3</option>
            <option value="4">Octave 4</option>
          </select>
          <input type="number" id="bassNoteCount" min="4" max="32" value="8" disabled>
          <label for="bassNoteCount">notes</label>
        </div>
        <button id="bassBtn" class="blue" disabled>Add Random Bassline</button>
      </div>
      
      <!-- Drum Controls -->
      <div class="control-group">
        <h3>Drums</h3>
        <div class="pattern-controls">
          <select id="drumPattern" disabled>
            <option value="basic">Basic</option>
            <option value="rock">Rock</option>
            <option value="jazz">Jazz</option>
            <option value="funk">Funk</option>
          </select>
          <select id="drumMeasures" disabled>
            <option value="1">1 Measure</option>
            <option value="2" selected>2 Measures</option>
            <option value="4">4 Measures</option>
          </select>
        </div>
        <button id="drumBtn" class="blue" disabled>Add Drums</button>
      </div>
      
      <!-- Clear Button -->
      <div class="control-group">
        <h3>Clear</h3>
        <button id="clearBtn" class="red" disabled>Clear All Notes</button>
        <div class="info-text">Remove all notes from the current sequence.</div>
      </div>
    </div>
  </div>
  
  <div class="card">
    <h2>3. Play Music</h2>
    <div class="controls">
      <button id="playBtn" disabled>‚ñ∂Ô∏è Play</button>
      <button id="stopBtn" disabled>‚èπÔ∏è Stop</button>
      <span id="playStatus">Nothing to play</span>
    </div>
  </div>

  <div class="card">
    <h2>4. Import/Export</h2>
    <div class="controls">
      <button id="exportMidiBtn" class="purple" disabled>üíæ Export to MIDI File</button>
      <button id="exportJsonBtn" class="purple" disabled>üìÑ Export as JSON</button>
      <button id="importBtn" class="orange" disabled>üìÇ Import</button>
      <span id="exportStatus">Create music to export</span>
    </div>
    <p class="info-text">Export your song as a .mid file to open in any DAW (Ableton, Logic, FL Studio, etc.) or as JSON for sharing and reimporting.</p>
    
    <div id="exportArea" class="hidden">
      <p>Exported MIDI Data (JSON format):</p>
      <textarea id="exportText" readonly></textarea>
      <p>Save this JSON data or copy it to import later.</p>
      <button id="copyJsonBtn" class="blue">Copy to Clipboard</button>
      <button id="saveJsonBtn" class="blue">Save as File</button>
    </div>
    
    <div id="importArea" class="hidden">
      <p>Paste MIDI Data (JSON format) to import:</p>
      <textarea id="importText"></textarea>
      <button id="processImportBtn" class="orange">Process Import</button>
      <p>Or upload a JSON file:</p>
      <input type="file" id="fileInput" accept=".json">
    </div>
  </div>
  
  <div class="card">
    <h2>Piano Roll</h2>
    <div id="piano-roll"></div>
  </div>
  
  <div class="status">Status: Ready</div>
  <div class="log" id="log"></div>
  
  <script>
    // Global state
    let state = {
      sessionId: null,
      sequenceId: null,
      audioContext: null,
      isPlaying: false,
      oscillators: [],
      noteCount: 0
    };
    
    // DOM elements
    const setupStatus = document.getElementById('setupStatus');
    const playStatus = document.getElementById('playStatus');
    const exportStatus = document.getElementById('exportStatus');
    const pianoRoll = document.getElementById('piano-roll');
    const statusBar = document.querySelector('.status');
    const logElement = document.getElementById('log');
    const exportText = document.getElementById('exportText');
    const importText = document.getElementById('importText');
    const exportArea = document.getElementById('exportArea');
    const importArea = document.getElementById('importArea');
    const fileInput = document.getElementById('fileInput');
    
    // Pattern controls
    const chordKey = document.getElementById('chordKey');
    const chordScale = document.getElementById('chordScale');
    const chordOctave = document.getElementById('chordOctave');
    const noteCount = document.getElementById('noteCount');
    
    const bassKey = document.getElementById('bassKey');
    const bassScale = document.getElementById('bassScale');
    const bassOctave = document.getElementById('bassOctave');
    const bassNoteCount = document.getElementById('bassNoteCount');
    
    const drumPattern = document.getElementById('drumPattern');
    const drumMeasures = document.getElementById('drumMeasures');
    
    // Buttons
    const setupBtn = document.getElementById('setupBtn');
    const chordBtn = document.getElementById('chordBtn');
    const bassBtn = document.getElementById('bassBtn');
    const drumBtn = document.getElementById('drumBtn');
    const clearBtn = document.getElementById('clearBtn');
    const playBtn = document.getElementById('playBtn');
    const stopBtn = document.getElementById('stopBtn');
    const exportMidiBtn = document.getElementById('exportMidiBtn');
    const exportJsonBtn = document.getElementById('exportJsonBtn');
    const importBtn = document.getElementById('importBtn');
    const processImportBtn = document.getElementById('processImportBtn');
    const copyJsonBtn = document.getElementById('copyJsonBtn');
    const saveJsonBtn = document.getElementById('saveJsonBtn');
    
    // Logging function
    function log(message, type = 'info') {
      console.log(message);
      const entry = document.createElement('div');
      entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
      entry.className = type;
      logElement.appendChild(entry);
      logElement.scrollTop = logElement.scrollHeight;
    }
    
    // Update status
    function updateStatus(message) {
      statusBar.textContent = 'Status: ' + message;
    }
    
    // API helper
    async function callApi(endpoint, method = 'GET', body = null) {
      try {
        const options = {
          method,
          headers: { 'Content-Type': 'application/json' }
        };

        if (body) {
          options.body = JSON.stringify(body);
        }

        log(`API Call: ${method} ${endpoint}`);
        const response = await fetch(`/api${endpoint}`, options);
        
        if (!response.ok) {
          const errorText = await response.text();
          log(`API error (${response.status}): ${errorText}`, 'error');
          return null;
        }
        
        // For binary responses (like MIDI files), return the Response object
        if (response.headers.get('Content-Type') === 'audio/midi') {
          return response;
        }
        
        const data = await response.json();

        if (!data.success) {
          log(`API Error: ${data.message}`, 'error');
          return null;
        }

        return data;
      } catch (error) {
        log(`Error: ${error.message}`, 'error');
        return null;
      }
    }
    
    // Initialize audio context
    function initAudio() {
      try {
        state.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        log('Audio initialized', 'success');
        return true;
      } catch (error) {
        log(`Audio initialization error: ${error.message}`, 'error');
        return false;
      }
    }
    
    // Setup (create session and sequence)
    async function setup() {
      // Create session
      const sessionData = await callApi('/sessions', 'POST', {});
      if (!sessionData) {
        log('Failed to create session', 'error');
        return false;
      }
      
      state.sessionId = sessionData.sessionId;
      log(`Session created: ${state.sessionId}`, 'success');
      
      // Create sequence
      const sequenceData = await callApi(`/sessions/${state.sessionId}/sequences`, 'POST', {
        name: 'My Music',
        tempo: 120,
        key: 'C major'
      });
      
      if (!sequenceData) {
        log('Failed to create sequence', 'error');
        return false;
      }
      
      state.sequenceId = sequenceData.sequenceId;
      log(`Sequence created: ${state.sequenceId}`, 'success');
      
      // Update UI
      setupStatus.textContent = `Ready (Session: ${state.sessionId.substring(0, 8)}...)`;
      
      // Enable all controls
      chordBtn.disabled = false;
      bassBtn.disabled = false;
      drumBtn.disabled = false;
      clearBtn.disabled = false;
      exportMidiBtn.disabled = false;
      exportJsonBtn.disabled = false;
      importBtn.disabled = false;
      
      // Enable all pattern selectors
      chordKey.disabled = false;
      chordScale.disabled = false;
      chordOctave.disabled = false;
      noteCount.disabled = false;
      
      bassKey.disabled = false;
      bassScale.disabled = false;
      bassOctave.disabled = false;
      bassNoteCount.disabled = false;
      
      drumPattern.disabled = false;
      drumMeasures.disabled = false;
      
      // Get piano roll ready
      initPianoRoll();
      
      return true;
    }
    
    // Generate random notes
    async function generateChords() {
      if (!state.sessionId || !state.sequenceId) {
        log('Set up session first', 'error');
        return;
      }
      
      updateStatus('Generating random notes...');
      
      // Get values from selectors
      const key = chordKey.value;
      const scaleType = chordScale.value;
      const octave = parseInt(chordOctave.value);
      const count = parseInt(noteCount.value) || 8;
      
      const data = await callApi(`/sessions/${state.sessionId}/patterns/chord-progression`, 'POST', {
        key,
        scaleType,
        octave,
        noteCount: count,
        rhythmPattern: [1]
      });
      
      if (!data) {
        updateStatus('Failed to generate random notes');
        return;
      }
      
      state.noteCount = data.noteCount;
      updateStatus(`Generated ${data.noteCount} random notes in ${key} ${scaleType}`);
      log(`Added ${data.noteCount} random notes in ${key} ${scaleType} at octave ${octave}`, 'success');
      
      // Refresh piano roll
      refreshPianoRoll();
      
      // Enable play and export buttons
      playBtn.disabled = false;
      stopBtn.disabled = false;
      exportMidiBtn.disabled = false;
      exportJsonBtn.disabled = false;
      playStatus.textContent = `${state.noteCount} notes ready to play`;
      exportStatus.textContent = `Ready to export`;
    }
    
    // Generate random bassline
    async function generateBass() {
      if (!state.sessionId || !state.sequenceId) {
        log('Set up session first', 'error');
        return;
      }
      
      updateStatus('Generating random bassline...');
      
      // Get values from selectors
      const key = bassKey.value;
      const scaleType = bassScale.value;
      const octave = parseInt(bassOctave.value);
      const count = parseInt(bassNoteCount.value) || 8;
      
      const data = await callApi(`/sessions/${state.sessionId}/patterns/bassline`, 'POST', {
        key,
        scaleType,
        octave,
        noteCount: count,
        rhythmPattern: [1, 0.5, 0.5]
      });
      
      if (!data) {
        updateStatus('Failed to generate bassline');
        return;
      }
      
      state.noteCount = data.noteCount;
      updateStatus(`Added ${key} ${scaleType} bassline with ${data.noteCount} notes`);
      log(`Added bassline in ${key} ${scaleType} at octave ${octave}`, 'success');
      
      // Refresh piano roll
      refreshPianoRoll();
      
      // Enable play and export buttons
      playBtn.disabled = false;
      stopBtn.disabled = false;
      exportMidiBtn.disabled = false;
      exportJsonBtn.disabled = false;
      playStatus.textContent = `${state.noteCount} notes ready to play`;
      exportStatus.textContent = `Ready to export`;
    }
    
    // Generate drums
    async function generateDrums() {
      if (!state.sessionId || !state.sequenceId) {
        log('Set up session first', 'error');
        return;
      }
      
      updateStatus('Generating drum pattern...');
      
      // Get values from selectors
      const patternType = drumPattern.value;
      const measures = parseInt(drumMeasures.value);
      
      const data = await callApi(`/sessions/${state.sessionId}/patterns/drums`, 'POST', {
        patternType,
        measures
      });
      
      if (!data) {
        updateStatus('Failed to generate drum pattern');
        return;
      }
      
      state.noteCount = data.noteCount;
      updateStatus(`Added ${patternType} drums for ${measures} measures (total: ${data.noteCount} notes)`);
      log(`Added ${patternType} drum pattern for ${measures} measures`, 'success');
      
      // Refresh piano roll
      refreshPianoRoll();
      
      // Enable play and export buttons
      playBtn.disabled = false;
      stopBtn.disabled = false;
      exportMidiBtn.disabled = false;
      exportJsonBtn.disabled = false;
      playStatus.textContent = `${state.noteCount} notes ready to play`;
      exportStatus.textContent = `Ready to export`;
    }
    
    // Clear all notes
    async function clearNotes() {
      if (!state.sessionId || !state.sequenceId) {
        log('Set up session first', 'error');
        return;
      }
      
      updateStatus('Clearing notes...');
      
      const data = await callApi(`/sessions/${state.sessionId}/notes`, 'DELETE');
      
      if (!data) {
        updateStatus('Failed to clear notes');
        return;
      }
      
      state.noteCount = 0;
      updateStatus('All notes cleared');
      log('Notes cleared', 'success');
      
      // Refresh piano roll
      refreshPianoRoll();
      
      // Disable play and export buttons
      playBtn.disabled = true;
      stopBtn.disabled = true;
      exportMidiBtn.disabled = true;
      exportJsonBtn.disabled = true;
      playStatus.textContent = 'Nothing to play';
      exportStatus.textContent = 'Create music to export';
    }
    
    // Export MIDI file
    async function exportMidiFile() {
      if (!state.sessionId || !state.sequenceId) {
        log('Set up session first', 'error');
        return;
      }
      
      if (state.noteCount === 0) {
        log('No notes to export', 'error');
        updateStatus('No notes to export');
        return;
      }
      
      updateStatus('Exporting MIDI file...');
      
      try {
        // Trigger file download using the export endpoint
        const response = await callApi(`/sessions/${state.sessionId}/export/midi`);
        
        if (!response) {
          throw new Error('Failed to get MIDI file from server');
        }
        
        // Get the blob from response
        const blob = await response.blob();
        
        // Create a download link
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.style.display = 'none';
        a.href = url;
        
        // Extract filename from the Content-Disposition header if possible
        const disposition = response.headers.get('Content-Disposition');
        let filename = 'my_music.mid';
        if (disposition && disposition.indexOf('attachment') !== -1) {
          const filenameRegex = /filename[^;=\\n]*=((['\"]).*?\\2|[^;\\n]*)/;
          const matches = filenameRegex.exec(disposition);
          if (matches != null && matches[1]) { 
            filename = matches[1].replace(/['\"]/g, '');
          }
        }
        
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        
        // Clean up
        window.URL.revokeObjectURL(url);
        document.body.removeChild(a);
        
        updateStatus(`Exported MIDI file successfully: ${filename}`);
        log(`Exported MIDI file: ${filename}`, 'success');
        exportStatus.textContent = `MIDI file exported successfully`;
      } catch (error) {
        console.error(error);
        log(`Error exporting MIDI: ${error.message}`, 'error');
        updateStatus('Failed to export MIDI file');
      }
    }
    
    // Export as JSON
    async function exportJson() {
      if (!state.sessionId || !state.sequenceId) {
        log('Set up session first', 'error');
        return;
      }
      
      updateStatus('Exporting JSON data...');
      
      const data = await callApi(`/sessions/${state.sessionId}/export/json`, 'GET');
      
      if (!data) {
        updateStatus('Failed to export JSON data');
        return;
      }
      
      // Show exported data in textarea
      exportText.value = JSON.stringify(data.data, null, 2);
      exportArea.classList.remove('hidden');
      importArea.classList.add('hidden');
      
      updateStatus(`Exported ${data.noteCount} notes to JSON format`);
      log(`Exported sequence ${data.sequenceId}`, 'success');
    }
    
    // Copy JSON to clipboard
    function copyJsonToClipboard() {
      exportText.select();
      document.execCommand('copy');
      log('JSON data copied to clipboard', 'success');
    }
    
    // Save JSON to file
    function saveJsonToFile() {
      const blob = new Blob([exportText.value], {type: 'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.style.display = 'none';
      a.href = url;
      a.download = 'midi_sequence.json';
      document.body.appendChild(a);
      a.click();
      URL.revokeObjectURL(url);
      document.body.removeChild(a);
      log('JSON data saved to file', 'success');
    }
    
    // Show import area
    function showImportArea() {
      if (!state.sessionId) {
        log('Set up session first', 'error');
        return;
      }
      
      exportArea.classList.add('hidden');
      importArea.classList.remove('hidden');
      importText.value = '';
      importText.focus();
      
      updateStatus('Ready to import data');
    }
    
    // Process import
    async function processImport() {
      if (!state.sessionId) {
        log('Set up session first', 'error');
        return;
      }
      
      const jsonData = importText.value.trim();
      if (!jsonData) {
        log('No data to import', 'error');
        return;
      }
      
      updateStatus('Importing data...');
      
      // Parse JSON to validate it first
      try {
        JSON.parse(jsonData);
      } catch (e) {
        log(`Invalid JSON data: ${e.message}`, 'error');
        updateStatus('Invalid JSON data');
        return;
      }
      
      const data = await callApi(`/sessions/${state.sessionId}/import`, 'POST', {
        data: jsonData
      });
      
      if (!data) {
        updateStatus('Failed to import data');
        return;
      }
      
      state.sequenceId = data.sequenceId;
      state.noteCount = data.sequence.noteCount;
      
      updateStatus(`Imported ${data.sequence.noteCount} notes successfully`);
      log(`Imported sequence ${data.sequenceId}`, 'success');
      
      // Hide import area
      importArea.classList.add('hidden');
      
      // Refresh piano roll and update UI
      refreshPianoRoll();
      
      // Enable play button if notes were imported
      playBtn.disabled = data.sequence.noteCount === 0;
      stopBtn.disabled = data.sequence.noteCount === 0;
      exportMidiBtn.disabled = data.sequence.noteCount === 0;
      exportJsonBtn.disabled = data.sequence.noteCount === 0;
      playStatus.textContent = data.sequence.noteCount > 0 ? 
        `${data.sequence.noteCount} notes ready to play` : 'Nothing to play';
      exportStatus.textContent = data.sequence.noteCount > 0 ?
        `Ready to export` : 'Create music to export';
    }
    
    // Handle file upload
    function handleFileUpload(event) {
      const file = event.target.files[0];
      if (!file) return;
      
      const reader = new FileReader();
      reader.onload = function(e) {
        importText.value = e.target.result;
        log(`File loaded: ${file.name}`, 'success');
      };
      reader.onerror = function(e) {
        log(`Error reading file: ${e.target.error}`, 'error');
      };
      reader.readAsText(file);
    }
    
    // Initialize piano roll
    function initPianoRoll() {
      pianoRoll.innerHTML = '';
      
      // Create piano keys (just one octave for simplicity)
      const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
      
      for (let octave = 5; octave >= 2; octave--) {
        for (let i = 11; i >= 0; i--) {
          const note = noteNames[i];
          const isBlack = note.includes('#');
          
          const pianoKey = document.createElement('div');
          pianoKey.className = `piano-key ${isBlack ? 'black' : 'white'}`;
          const midiNote = octave * 12 + i;
          pianoKey.dataset.note = midiNote;
          pianoKey.style.top = `${(127 - midiNote) * 20}px`;
          pianoKey.textContent = `${note}${octave}`;
          
          pianoRoll.appendChild(pianoKey);
        }
      }
    }
    
    // Refresh piano roll with notes
    async function refreshPianoRoll() {
      // Get sequence data
      const data = await callApi(`/sessions/${state.sessionId}/sequences/${state.sequenceId}`);
      if (!data) {
        log('Failed to get sequence data', 'error');
        return;
      }
      
      // Clear existing notes
      document.querySelectorAll('.piano-note').forEach(note => note.remove());
      
      // Add notes
      if (data.sequence.notes && data.sequence.notes.length > 0) {
        data.sequence.notes.forEach(note => {
          const noteElement = document.createElement('div');
          
          // Select class based on channel
          if (note.channel === 9) {
            noteElement.className = 'piano-note drum-note';
          } else if (note.channel === 1) {
            noteElement.className = 'piano-note bassline-note';
          } else {
            noteElement.className = 'piano-note';
          }
          
          // Position and size
          noteElement.style.top = `${(127 - note.pitch) * 20 + 1}px`;
          noteElement.style.left = `${note.startTime * 30 + 100}px`;
          noteElement.style.width = `${note.duration * 30}px`;
          
          // Add data for playback
          noteElement.dataset.pitch = note.pitch;
          noteElement.dataset.start = note.startTime;
          noteElement.dataset.duration = note.duration;
          noteElement.dataset.velocity = note.velocity;
          noteElement.dataset.channel = note.channel;
          
          // Add note name for better visibility
          noteElement.textContent = note.pitch;
          
          pianoRoll.appendChild(noteElement);
        });
        
        log(`Displayed ${data.sequence.notes.length} notes in piano roll`, 'success');
      }
    }
    
    // Sync key and scale between melody and bass controls
    function syncMusicSettings(source, target) {
      if (source === 'chord') {
        bassKey.value = chordKey.value;
        bassScale.value = chordScale.value;
      } else {
        chordKey.value = bassKey.value;
        chordScale.value = bassScale.value;
      }
    }
    
    // Play the sequence
    function playSequence() {
      if (!state.audioContext) {
        initAudio();
      }
      
      if (state.isPlaying) {
        stopPlayback();
      }
      
      // Refresh notes to make sure we have the latest
      refreshPianoRoll().then(() => {
        const notes = document.querySelectorAll('.piano-note');
        if (notes.length === 0) {
          updateStatus('No notes to play');
          return;
        }
        
        state.isPlaying = true;
        updateStatus('Playing...');
        playStatus.textContent = 'Playing...';
        
        const startTime = state.audioContext.currentTime;
        const tempo = 120; // beats per minute
        const secondsPerBeat = 60 / tempo;
        
        notes.forEach(noteElement => {
          // Skip drum notes for now (they sound strange)
          if (parseInt(noteElement.dataset.channel) === 9) {
            return;
          }
          
          const pitch = parseInt(noteElement.dataset.pitch);
          const noteStartTime = startTime + (parseFloat(noteElement.dataset.start) * secondsPerBeat);
          const noteDuration = parseFloat(noteElement.dataset.duration) * secondsPerBeat;
          const velocity = parseInt(noteElement.dataset.velocity) / 127;
          
          // Create oscillator
          const oscillator = state.audioContext.createOscillator();
          const gainNode = state.audioContext.createGain();
          
          // Configure oscillator
          oscillator.type = parseInt(noteElement.dataset.channel) === 1 ? 'triangle' : 'sine';
          oscillator.frequency.value = midiToFrequency(pitch);
          
          // Connect
          oscillator.connect(gainNode);
          gainNode.connect(state.audioContext.destination);
          
          // Set volume
          gainNode.gain.value = velocity * 0.2;
          
          // Schedule note
          oscillator.start(noteStartTime);
          oscillator.stop(noteStartTime + noteDuration);
          
          // Add visual feedback
          setTimeout(() => {
            noteElement.style.backgroundColor = 'yellow';
            setTimeout(() => {
              if (noteElement.dataset.channel === '9') {
                noteElement.style.backgroundColor = '#db4437';
              } else if (noteElement.dataset.channel === '1') {
                noteElement.style.backgroundColor = '#0f9d58';
              } else {
                noteElement.style.backgroundColor = '#4285f4';
              }
            }, noteDuration * 1000);
          }, (noteStartTime - startTime) * 1000);
          
          // Save for cleanup
          state.oscillators.push(oscillator);
        });
        
        // Find the longest note to stop playback
        const longestDuration = Math.max(...Array.from(notes).map(note => 
          parseFloat(note.dataset.start) + parseFloat(note.dataset.duration)
        ));
        
        // Auto-stop at end
        setTimeout(() => {
          if (state.isPlaying) {
            stopPlayback();
          }
        }, longestDuration * secondsPerBeat * 1000);
      });
    }
    
    // Stop playback
    function stopPlayback() {
      if (!state.isPlaying) return;
      
      // Stop all oscillators
      state.oscillators.forEach(osc => {
        try {
          osc.stop();
        } catch (e) {
          // Ignore errors for oscillators that are already stopped
        }
      });
      
      state.oscillators = [];
      state.isPlaying = false;
      
      updateStatus('Playback stopped');
      playStatus.textContent = `${state.noteCount} notes ready to play`;
    }
    
    // Convert MIDI note to frequency
    function midiToFrequency(note) {
      return 440 * Math.pow(2, (note - 69) / 12);
    }
    
    // Event listeners
    setupBtn.addEventListener('click', setup);
    chordBtn.addEventListener('click', generateChords);
    bassBtn.addEventListener('click', generateBass);
    drumBtn.addEventListener('click', generateDrums);
    clearBtn.addEventListener('click', clearNotes);
    playBtn.addEventListener('click', playSequence);
    stopBtn.addEventListener('click', stopPlayback);
    exportMidiBtn.addEventListener('click', exportMidiFile);
    exportJsonBtn.addEventListener('click', exportJson);
    importBtn.addEventListener('click', showImportArea);
    processImportBtn.addEventListener('click', processImport);
    copyJsonBtn.addEventListener('click', copyJsonToClipboard);
    saveJsonBtn.addEventListener('click', saveJsonToFile);
    fileInput.addEventListener('change', handleFileUpload);
    
    // Add music setting sync
    chordKey.addEventListener('change', () => syncMusicSettings('chord', 'bass'));
    chordScale.addEventListener('change', () => syncMusicSettings('chord', 'bass'));
    bassKey.addEventListener('change', () => syncMusicSettings('bass', 'chord'));
    bassScale.addEventListener('change', () => syncMusicSettings('bass', 'chord'));
    
    // Initialize
    updateStatus('Ready - click "Set Up" to begin');
    log('Interface loaded, click "Set Up" to begin', 'success');
  </script>
</body>
</html>