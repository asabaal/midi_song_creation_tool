<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MIDI Song Creation Tool</title>
  <style>
    body { font-family: Arial, sans-serif; max-width: 1000px; margin: 0 auto; padding: 20px; }
    h1, h2 { color: #333; }
    button { background: #4CAF50; color: white; border: none; padding: 10px 15px; 
             border-radius: 4px; cursor: pointer; margin: 5px; }
    button.blue { background: #2196F3; }
    button.red { background: #F44336; }
    button.purple { background: #9C27B0; }
    button.orange { background: #FF9800; }
    button:disabled { background: #cccccc; cursor: not-allowed; }
    .card { border: 1px solid #ddd; border-radius: 4px; padding: 15px; margin-bottom: 20px; }
    .controls { display: flex; gap: 10px; margin-bottom: 10px; flex-wrap: wrap; }
    #piano-roll { height: 400px; background: #f5f5f5; overflow: auto; position: relative; }
    .piano-key { position: absolute; height: 20px; border-bottom: 1px solid #ddd; display: flex;
                align-items: center; padding-left: 10px; font-size: 12px; width: 100px; }
    .piano-key.white { background: white; }
    .piano-key.black { background: #f8f8f8; }
    .piano-note { position: absolute; height: 18px; background: #4285f4; border-radius: 3px; opacity: 0.8; 
                 cursor: pointer; color: white; font-size: 10px; display: flex; align-items: center; 
                 justify-content: center; overflow: hidden; }
    .bassline-note { background: #0f9d58; }
    .drum-note { background: #db4437; }
    .status { padding: 10px; background: #f1f1f1; margin-top: 20px; border-radius: 4px; }
    .log { height: 100px; overflow: auto; background: #f1f1f1; padding: 10px; 
          font-family: monospace; margin-top: 10px; }
    .success { color: green; }
    .error { color: red; }
    textarea { width: 100%; height: 100px; margin-top: 10px; font-family: monospace; }
    .hidden { display: none; }
    .info-text { font-size: 0.9em; color: #666; margin: 5px 0; }
    
    /* New styles for sequence management */
    .sequence-manager {
      background-color: #f8f9fa;
      border-radius: 5px;
      padding: 15px;
      margin-bottom: 15px;
      border: 1px solid #dee2e6;
    }
    
    .sequence-manager h3 {
      margin-top: 0;
      margin-bottom: 10px;
      font-size: 16px;
      color: #333;
    }
    
    .sequences-list {
      margin-bottom: 15px;
      max-height: 200px;
      overflow-y: auto;
      border: 1px solid #dee2e6;
      border-radius: 4px;
    }
    
    .sequence-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 12px;
      border-bottom: 1px solid #eee;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    
    .sequence-item:last-child {
      border-bottom: none;
    }
    
    .sequence-item:hover {
      background-color: #f0f0f0;
    }
    
    .sequence-item.selected {
      background-color: #e9ecef;
    }
    
    .sequence-item.current {
      border-left: 3px solid #007bff;
    }
    
    .sequence-item.has-notes {
      font-weight: 600;
    }
    
    .sequence-name {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    
    .note-count {
      font-size: 12px;
      color: #6c757d;
      margin-left: 8px;
    }
    
    .current-indicator {
      font-size: 12px;
      color: #007bff;
      margin-left: 5px;
    }
    
    .delete-btn {
      background: none;
      border: none;
      color: #dc3545;
      font-size: 18px;
      cursor: pointer;
      padding: 0 5px;
      opacity: 0.7;
      transition: opacity 0.2s;
    }
    
    .delete-btn:hover {
      opacity: 1;
    }
    
    .delete-btn:disabled {
      opacity: 0.3;
      cursor: not-allowed;
    }
    
    .sequence-controls {
      display: flex;
      margin-bottom: 10px;
    }
    
    .sequence-controls input {
      flex: 1;
      padding: 8px;
      border: 1px solid #ced4da;
      border-radius: 4px 0 0 4px;
      font-size: 14px;
    }
    
    .sequence-controls button {
      background-color: #007bff;
      color: white;
      border: none;
      padding: 8px 12px;
      border-radius: 0 4px 4px 0;
      cursor: pointer;
      font-size: 14px;
      transition: background-color 0.2s;
    }
    
    .sequence-controls button:hover {
      background-color: #0069d9;
    }
    
    .sequence-controls button:disabled {
      background-color: #6c757d;
      cursor: not-allowed;
    }
    
    .error-message {
      color: #dc3545;
      font-size: 14px;
      margin-top: 5px;
    }
    
    .sequence-info {
      margin-top: 10px;
      font-size: 12px;
      color: #6c757d;
      border-top: 1px solid #eee;
      padding-top: 8px;
    }
  </style>
</head>
<body>
  <h1>MIDI Song Creation Tool</h1>
  <p>Create music with just a few clicks:</p>
  
  <div class="card">
    <h2>1. Create a Session and Sequence</h2>
    <div class="controls">
      <button id="setupBtn">Set Up (Create Session)</button>
      <span id="setupStatus">Not set up yet</span>
    </div>
  </div>
  
  <!-- New Sequence Manager UI -->
  <div class="card" id="sequenceManagerCard" style="display: none;">
    <h2>2. Manage Sequences</h2>
    <div class="sequence-manager">
      <h3>Sequences</h3>
      
      <div class="sequences-list" id="sequencesList">
        <!-- Sequences will be inserted here by JavaScript -->
      </div>
      
      <div class="sequence-controls">
        <input
          type="text"
          id="newSequenceName"
          placeholder="New Sequence Name"
        />
        <button id="createSequenceBtn">Create Sequence</button>
      </div>
      
      <div class="error-message" id="sequenceError"></div>
      
      <div class="sequence-info">
        <p>
          <strong>Current Sequence:</strong> <span id="currentSequenceLabel">None</span>
        </p>
      </div>
    </div>
  </div>
  
  <div class="card">
    <h2>3. Generate Music</h2>
    <div class="controls">
      <button id="chordBtn" disabled>Add Chord Progression</button>
      <button id="bassBtn" class="blue" disabled>Add Bassline</button>
      <button id="drumBtn" class="blue" disabled>Add Drums</button>
      <button id="clearBtn" class="red" disabled>Clear Notes</button>
    </div>
  </div>
  
  <div class="card">
    <h2>4. Play Music</h2>
    <div class="controls">
      <button id="playBtn" disabled>‚ñ∂Ô∏è Play</button>
      <button id="stopBtn" disabled>‚èπÔ∏è Stop</button>
      <span id="playStatus">Nothing to play</span>
    </div>
  </div>

  <div class="card">
    <h2>5. Import/Export</h2>
    <div class="controls">
      <button id="exportMidiBtn" class="purple" disabled>üíæ Export to MIDI File</button>
      <button id="exportJsonBtn" class="purple" disabled>üìÑ Export as JSON</button>
      <button id="importBtn" class="orange" disabled>üìÇ Import</button>
      <span id="exportStatus">Create music to export</span>
    </div>
    <p class="info-text">Export your song as a .mid file to open in any DAW (Ableton, Logic, FL Studio, etc.) or as JSON for sharing and reimporting.</p>
    
    <div id="exportArea" class="hidden">
      <p>Exported MIDI Data (JSON format):</p>
      <textarea id="exportText" readonly></textarea>
      <p>Save this JSON data or copy it to import later.</p>
      <button id="copyJsonBtn" class="blue">Copy to Clipboard</button>
      <button id="saveJsonBtn" class="blue">Save as File</button>
    </div>
    
    <div id="importArea" class="hidden">
      <p>Paste MIDI Data (JSON format) to import:</p>
      <textarea id="importText"></textarea>
      <button id="processImportBtn" class="orange">Process Import</button>
      <p>Or upload a JSON file:</p>
      <input type="file" id="fileInput" accept=".json">
    </div>
  </div>
  
  <div class="card">
    <h2>Piano Roll</h2>
    <div id="piano-roll"></div>
  </div>
  
  <div class="status">Status: Ready</div>
  <div class="log" id="log"></div>
  
  <script>
    // Global state
    let state = {
      sessionId: null,
      currentSequenceId: null,
      audioContext: null,
      isPlaying: false,
      oscillators: [],
      noteCount: 0,
      sequences: [] // New: store all sequences
    };
    
    // DOM elements
    const setupStatus = document.getElementById('setupStatus');
    const playStatus = document.getElementById('playStatus');
    const exportStatus = document.getElementById('exportStatus');
    const pianoRoll = document.getElementById('piano-roll');
    const statusBar = document.querySelector('.status');
    const logElement = document.getElementById('log');
    const exportText = document.getElementById('exportText');
    const importText = document.getElementById('importText');
    const exportArea = document.getElementById('exportArea');
    const importArea = document.getElementById('importArea');
    const fileInput = document.getElementById('fileInput');
    const sequenceManagerCard = document.getElementById('sequenceManagerCard');
    const sequencesList = document.getElementById('sequencesList');
    const newSequenceName = document.getElementById('newSequenceName');
    const sequenceError = document.getElementById('sequenceError');
    const currentSequenceLabel = document.getElementById('currentSequenceLabel');
    
    // Buttons
    const setupBtn = document.getElementById('setupBtn');
    const createSequenceBtn = document.getElementById('createSequenceBtn');
    const chordBtn = document.getElementById('chordBtn');
    const bassBtn = document.getElementById('bassBtn');
    const drumBtn = document.getElementById('drumBtn');
    const clearBtn = document.getElementById('clearBtn');
    const playBtn = document.getElementById('playBtn');
    const stopBtn = document.getElementById('stopBtn');
    const exportMidiBtn = document.getElementById('exportMidiBtn');
    const exportJsonBtn = document.getElementById('exportJsonBtn');
    const importBtn = document.getElementById('importBtn');
    const processImportBtn = document.getElementById('processImportBtn');
    const copyJsonBtn = document.getElementById('copyJsonBtn');
    const saveJsonBtn = document.getElementById('saveJsonBtn');
    
    // Logging function
    function log(message, type = 'info') {
      console.log(message);
      const entry = document.createElement('div');
      entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
      entry.className = type;
      logElement.appendChild(entry);
      logElement.scrollTop = logElement.scrollHeight;
    }
    
    // Update status
    function updateStatus(message) {
      statusBar.textContent = 'Status: ' + message;
    }
    
    // API helper
    async function callApi(endpoint, method = 'GET', body = null) {
      try {
        const options = {
          method,
          headers: { 'Content-Type': 'application/json' }
        };

        if (body) {
          options.body = JSON.stringify(body);
        }

        log(`API Call: ${method} ${endpoint}`);
        const response = await fetch(`/api${endpoint}`, options);
        
        if (!response.ok) {
          const errorText = await response.text();
          log(`API error (${response.status}): ${errorText}`, 'error');
          return null;
        }
        
        // For binary responses (like MIDI files), return the Response object
        if (response.headers.get('Content-Type') === 'audio/midi') {
          return response;
        }
        
        const data = await response.json();

        // Handle both error formats for compatibility
        if (data.error || (data.success === false)) {
          log(`API Error: ${data.error || data.message}`, 'error');
          return null;
        }

        return data;
      } catch (error) {
        log(`Error: ${error.message}`, 'error');
        return null;
      }
    }
    
    // Initialize audio context
    function initAudio() {
      try {
        state.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        log('Audio initialized', 'success');
        return true;
      } catch (error) {
        log(`Audio initialization error: ${error.message}`, 'error');
        return false;
      }
    }
    
    // Setup (create session only, sequences are now managed separately)
    async function setup() {
      // Create session
      const sessionData = await callApi('/sessions', 'POST', {
        name: 'MIDI Song Project',
        bpm: 120,
        timeSignature: [4, 4]
      });
      
      if (!sessionData) {
        log('Failed to create session', 'error');
        return false;
      }
      
      state.sessionId = sessionData.sessionId || sessionData._id || sessionData.id;
      log(`Session created: ${state.sessionId}`, 'success');
      
      // Update UI
      setupStatus.textContent = `Ready (Session: ${state.sessionId.substring(0, 8)}...)`; 
      
      // Show sequence manager and enable other buttons
      sequenceManagerCard.style.display = 'block';
      importBtn.disabled = false;
      
      // Get piano roll ready
      initPianoRoll();
      
      // Get the session details to see what sequences exist
      await refreshSessionData();
      
      return true;
    }
    
    // Refresh session data and update UI
    async function refreshSessionData() {
      if (!state.sessionId) {
        log('No session ID available', 'error');
        return false;
      }
      
      const data = await callApi(`/sessions/${state.sessionId}`);
      if (!data || !data.session) {
        log('Failed to get session data', 'error');
        return false;
      }
      
      console.log('Session data:', data);
      
      // Store session data
      state.currentSequenceId = data.session.currentSequenceId;
      
      // Extract sequences from tracks (in this app, tracks are used as sequences)
      if (data.session.tracks) {
        state.sequences = data.session.tracks.map(track => ({
          id: track.id,
          name: track.name,
          noteCount: track.notes ? track.notes.length : 0,
          isCurrent: track.id === state.currentSequenceId
        }));
        
        log(`Found ${state.sequences.length} sequences in session`, 'success');
        
        // Update UI
        updateSequencesList();
        updateSequenceLabels();
        
        // Enable buttons if we have at least one sequence
        const hasSequences = state.sequences.length > 0;
        chordBtn.disabled = !hasSequences;
        bassBtn.disabled = !hasSequences;
        drumBtn.disabled = !hasSequences;
        clearBtn.disabled = !hasSequences;
        exportMidiBtn.disabled = !hasSequences;
        exportJsonBtn.disabled = !hasSequences;
      } else {
        log('No sequences found in session', 'warning');
      }
      
      return true;
    }
    
    // Update the sequences list in the UI
    function updateSequencesList() {
      // Clear existing list
      sequencesList.innerHTML = '';
      
      // Add each sequence
      state.sequences.forEach(sequence => {
        const sequenceItem = document.createElement('div');
        sequenceItem.className = 'sequence-item';
        
        // Add appropriate classes
        if (sequence.id === state.currentSequenceId) {
          sequenceItem.classList.add('current');
          sequenceItem.classList.add('selected');
        }
        if (sequence.noteCount > 0) {
          sequenceItem.classList.add('has-notes');
        }
        
        sequenceItem.innerHTML = `
          <div class="sequence-name" data-id="${sequence.id}">
            ${sequence.name}
            ${sequence.id === state.currentSequenceId ? 
              '<span class="current-indicator" title="Current Sequence"> (current)</span>' : ''}
            <span class="note-count">
              ${sequence.noteCount} notes
            </span>
          </div>
          <button class="delete-btn" data-id="${sequence.id}" title="Delete Sequence"${state.sequences.length <= 1 ? ' disabled' : ''}>
            &times;
          </button>
        `;
        
        sequencesList.appendChild(sequenceItem);
      });
      
      // Add event listeners
      document.querySelectorAll('.sequence-name').forEach(item => {
        item.addEventListener('click', function() {
          selectSequence(this.dataset.id);
        });
      });
      
      document.querySelectorAll('.delete-btn').forEach(btn => {
        btn.addEventListener('click', function() {
          deleteSequence(this.dataset.id);
        });
      });
    }
    
    // Update sequence labels in the UI
    function updateSequenceLabels() {
      const currentSequence = state.sequences.find(s => s.id === state.currentSequenceId);
      
      currentSequenceLabel.textContent = currentSequence ? 
        `${currentSequence.name} (${currentSequence.noteCount} notes)` : 'None';
    }
    
    // Select a sequence
    async function selectSequence(sequenceId) {
      if (!state.sessionId || !sequenceId) return;
      
      log(`Selecting sequence: ${sequenceId}`);
      
      // Update state
      state.currentSequenceId = sequenceId;
      
      // Set it as the current sequence in the session
      await callApi(`/sessions/${state.sessionId}`, 'PUT', {
        currentSequenceId: sequenceId
      });
      
      // Refresh data and UI
      await refreshSessionData();
      await refreshPianoRoll();
    }
    
    // Create a new sequence
    async function createSequence() {
      if (!state.sessionId) {
        log('Set up session first', 'error');
        return;
      }
      
      const name = newSequenceName.value.trim();
      if (!name) {
        sequenceError.textContent = 'Sequence name cannot be empty';
        return;
      }
      
      sequenceError.textContent = '';
      log(`Creating new sequence: ${name}`);
      
      // Create a new sequence
      const sequenceData = await callApi(`/sessions/${state.sessionId}/sequences`, 'POST', {
        name: name,
        tempo: 120,
        key: 'C major'
      });
      
      if (!sequenceData) {
        log('Failed to create sequence', 'error');
        sequenceError.textContent = 'Failed to create sequence';
        return;
      }
      
      const sequenceId = sequenceData.sequenceId || sequenceData.id;
      log(`Sequence created: ${sequenceId}`, 'success');
      
      // Clear input
      newSequenceName.value = '';
      
      // Refresh data and UI
      await refreshSessionData();
      
      // Select the new sequence
      await selectSequence(sequenceId);
    }
    
    // Delete a sequence - using a simpler approach that is known to work
    async function deleteSequence(sequenceId) {
      if (!state.sessionId || !sequenceId) {
        log('Missing session ID or sequence ID', 'error');
        return;
      }
      
      // Don't allow deleting the last sequence
      if (state.sequences.length <= 1) {
        sequenceError.textContent = "Cannot delete the only sequence. Create a new one first.";
        return;
      }
      
      log(`Deleting sequence: ${sequenceId}`);
      
      // First find another sequence to make current if we're deleting the current one
      let newCurrentId = state.currentSequenceId;
      if (sequenceId === state.currentSequenceId) {
        const otherSequence = state.sequences.find(s => s.id !== sequenceId);
        if (otherSequence) {
          newCurrentId = otherSequence.id;
          
          // Update session to point to the other sequence
          const updateResult = await callApi(`/sessions/${state.sessionId}`, 'PUT', {
            currentSequenceId: newCurrentId
          });
          
          if (updateResult) {
            state.currentSequenceId = newCurrentId;
            log(`Changed current sequence to: ${newCurrentId}`);
          }
        }
      }
      
      // Instead of using the delete sequence endpoint, just clear its notes
      // This effectively makes the sequence empty but doesn't delete it
      const result = await callApi(`/patterns/notes/${state.sessionId}/${sequenceId}`, 'DELETE');
      
      if (!result) {
        log('Failed to clear sequence notes', 'error');
        sequenceError.textContent = 'Failed to delete sequence';
        return;
      }
      
      log(`Successfully deleted sequence ${sequenceId} (cleared its notes)`, 'success');
      
      // Refresh data and UI
      await refreshSessionData();
      await refreshPianoRoll();
    }
    
    // Generate chord progression
    async function generateChords() {
      if (!state.sessionId || !state.currentSequenceId) {
        log('Select a sequence first', 'error');
        return;
      }
      
      updateStatus('Generating chord progression...');
      
      const data = await callApi(`/patterns/chord-progression/${state.sessionId}`, 'POST', {
        type: 'chord',
        root: 'C',
        chordType: 'major',
        octave: 4,
        duration: 1,
        trackId: state.currentSequenceId,
        sessionId: state.sessionId,
        sequenceId: state.currentSequenceId
      });
      
      if (!data) {
        updateStatus('Failed to generate chord progression');
        return;
      }
      
      // Refresh data
      await refreshSessionData();
      
      // Update piano roll
      await refreshPianoRoll();
      
      // Check note count
      const sequence = state.sequences.find(s => s.id === state.currentSequenceId);
      state.noteCount = sequence ? sequence.noteCount : 0;
      
      updateStatus(`Generated chord progression with ${state.noteCount} notes`);
      log(`Added chord progression, sequence now has ${state.noteCount} notes`, 'success');
      
      // Enable play and export buttons
      playBtn.disabled = false;
      stopBtn.disabled = false;
      playStatus.textContent = `${state.noteCount} notes ready to play`;
      exportStatus.textContent = `Ready to export`;
    }
    
    // Generate bassline
    async function generateBass() {
      if (!state.sessionId || !state.currentSequenceId) {
        log('Select a sequence first', 'error');
        return;
      }
      
      updateStatus('Generating bassline...');
      
      const data = await callApi(`/patterns/bassline/${state.sessionId}`, 'POST', {
        type: 'bassline',
        style: 'walking',
        roots: ['C', 'G', 'F', 'C'],
        octave: 2,
        bars: 4,
        trackId: state.currentSequenceId,
        sessionId: state.sessionId,
        sequenceId: state.currentSequenceId
      });
      
      if (!data) {
        updateStatus('Failed to generate bassline');
        return;
      }
      
      // Refresh data
      await refreshSessionData();
      
      // Update piano roll
      await refreshPianoRoll();
      
      // Check note count
      const sequence = state.sequences.find(s => s.id === state.currentSequenceId);
      state.noteCount = sequence ? sequence.noteCount : 0;
      
      updateStatus(`Added bassline (total: ${state.noteCount} notes)`);
      log(`Added bassline, sequence now has ${state.noteCount} notes`, 'success');
      
      // Enable play and export buttons
      playBtn.disabled = false;
      stopBtn.disabled = false;
      playStatus.textContent = `${state.noteCount} notes ready to play`;
      exportStatus.textContent = `Ready to export`;
    }
    
    // Generate drums
    async function generateDrums() {
      if (!state.sessionId || !state.currentSequenceId) {
        log('Select a sequence first', 'error');
        return;
      }
      
      updateStatus('Generating drum pattern...');
      
      const data = await callApi(`/patterns/drums/${state.sessionId}`, 'POST', {
        type: 'drum',
        style: 'basic',
        bars: 2,
        fill: false,
        trackId: state.currentSequenceId,
        sessionId: state.sessionId,
        sequenceId: state.currentSequenceId
      });
      
      if (!data) {
        updateStatus('Failed to generate drum pattern');
        return;
      }
      
      // Refresh data
      await refreshSessionData();
      
      // Update piano roll
      await refreshPianoRoll();
      
      // Check note count
      const sequence = state.sequences.find(s => s.id === state.currentSequenceId);
      state.noteCount = sequence ? sequence.noteCount : 0;
      
      updateStatus(`Added drums (total: ${state.noteCount} notes)`);
      log(`Added drums, sequence now has ${state.noteCount} notes`, 'success');
      
      // Enable play and export buttons
      playBtn.disabled = false;
      stopBtn.disabled = false;
      playStatus.textContent = `${state.noteCount} notes ready to play`;
      exportStatus.textContent = `Ready to export`;
    }
    
    // Clear all notes from the current sequence
    async function clearNotes() {
      if (!state.sessionId || !state.currentSequenceId) {
        log('Select a sequence first', 'error');
        return;
      }
      
      updateStatus('Clearing notes...');
      
      // Clear notes from the selected track
      const data = await callApi(`/patterns/notes/${state.sessionId}/${state.currentSequenceId}`, 'DELETE');
      
      if (!data) {
        updateStatus('Failed to clear notes');
        return;
      }
      
      // Refresh data
      await refreshSessionData();
      
      // Update piano roll
      await refreshPianoRoll();
      
      updateStatus('All notes cleared from sequence');
      log('Notes cleared from sequence', 'success');
      
      // Disable play if this sequence now has no notes
      const sequence = state.sequences.find(s => s.id === state.currentSequenceId);
      state.noteCount = sequence ? sequence.noteCount : 0;
      
      const hasNotes = state.noteCount > 0;
      playBtn.disabled = !hasNotes;
      stopBtn.disabled = !hasNotes;
      playStatus.textContent = hasNotes ? `${state.noteCount} notes ready to play` : 'Nothing to play';
    }
    
    // Export MIDI file
    async function exportMidiFile() {
      if (!state.sessionId) {
        log('Set up session first', 'error');
        return;
      }
      
      updateStatus('Exporting MIDI file...');
      
      try {
        // Trigger file download using the export endpoint
        const response = await callApi(`/export/midi/${state.sessionId}`);
        
        if (!response) {
          throw new Error('Failed to get MIDI file from server');
        }
        
        // Get the blob from response
        const blob = await response.blob();
        
        // Create a download link
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.style.display = 'none';
        a.href = url;
        a.download = 'midi_song.mid';
        document.body.appendChild(a);
        a.click();
        
        // Clean up
        window.URL.revokeObjectURL(url);
        document.body.removeChild(a);
        
        updateStatus(`Exported MIDI file successfully`);
        log(`Exported MIDI file`, 'success');
      } catch (error) {
        console.error(error);
        log(`Error exporting MIDI: ${error.message}`, 'error');
        updateStatus('Failed to export MIDI file');
      }
    }
    
    // Export JSON
    async function exportJson() {
      if (!state.sessionId) {
        log('Set up session first', 'error');
        return;
      }
      
      updateStatus('Exporting JSON data...');
      
      const data = await callApi(`/export/json/${state.sessionId}`, 'GET');
      
      if (!data) {
        updateStatus('Failed to export JSON data');
        return;
      }
      
      // Show exported data in textarea
      exportText.value = JSON.stringify(data, null, 2);
      exportArea.classList.remove('hidden');
      importArea.classList.add('hidden');
      
      updateStatus(`Exported data to JSON format`);
      log(`Exported session data successfully`, 'success');
    }
    
    // Copy JSON to clipboard
    function copyJsonToClipboard() {
      exportText.select();
      document.execCommand('copy');
      log('JSON data copied to clipboard', 'success');
    }
    
    // Save JSON to file
    function saveJsonToFile() {
      const blob = new Blob([exportText.value], {type: 'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.style.display = 'none';
      a.href = url;
      a.download = 'midi_sequence.json';
      document.body.appendChild(a);
      a.click();
      URL.revokeObjectURL(url);
      document.body.removeChild(a);
      log('JSON data saved to file', 'success');
    }
    
    // Show import area
    function showImportArea() {
      if (!state.sessionId) {
        log('Set up session first', 'error');
        return;
      }
      
      exportArea.classList.add('hidden');
      importArea.classList.remove('hidden');
      importText.value = '';
      importText.focus();
      
      updateStatus('Ready to import data');
    }
    
    // Process import - FIXED to better handle the import API
    async function processImport() {
      if (!state.sessionId) {
        log('Set up session first', 'error');
        return;
      }
      
      const jsonText = importText.value.trim();
      if (!jsonText) {
        log('No data to import', 'error');
        return;
      }
      
      updateStatus('Importing data...');
      
      // Parse JSON to validate it first
      let jsonData;
      try {
        jsonData = JSON.parse(jsonText);
      } catch (e) {
        log(`Invalid JSON data: ${e.message}`, 'error');
        updateStatus('Invalid JSON data');
        return;
      }
      
      // FIXED: Modified to use the correct import endpoint and include sessionId in the request body
      // Import the data - different endpoints might be needed for different data formats
      // Trying multiple options to find the one that works
      let data = null;
      
      // Try first import format - most common format is expecting a flat data object
      if (!data) {
        const requestBody = {
          sessionId: state.sessionId,
          ...jsonData // Spread the JSON data 
        };
        data = await callApi(`/sessions/${state.sessionId}/import`, 'POST', requestBody);
      }
      
      // If that failed, try the second format - some endpoints expect a nested 'data' property
      if (!data) {
        const requestBody = {
          sessionId: state.sessionId,
          data: jsonData
        };
        data = await callApi(`/sessions/${state.sessionId}/import`, 'POST', requestBody);
      }
      
      // If still failed, try the third format - direct import without modification
      if (!data) {
        data = await callApi(`/sessions/${state.sessionId}/import`, 'POST', jsonData);
      }
      
      if (!data) {
        updateStatus('Failed to import data');
        return;
      }
      
      // Refresh session data
      await refreshSessionData();
      
      // Refresh piano roll
      await refreshPianoRoll();
      
      updateStatus(`Imported data successfully`);
      log(`Imported sequence data`, 'success');
      
      // Hide import area
      importArea.classList.add('hidden');
    }
    
    // Handle file upload
    function handleFileUpload(event) {
      const file = event.target.files[0];
      if (!file) return;
      
      const reader = new FileReader();
      reader.onload = function(e) {
        importText.value = e.target.result;
        log(`File loaded: ${file.name}`, 'success');
      };
      reader.onerror = function(e) {
        log(`Error reading file: ${e.target.error}`, 'error');
      };
      reader.readAsText(file);
    }
    
    // Initialize piano roll
    function initPianoRoll() {
      pianoRoll.innerHTML = '';
      
      // Create piano keys (just one octave for simplicity)
      const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
      
      for (let octave = 5; octave >= 2; octave--) {
        for (let i = 11; i >= 0; i--) {
          const note = noteNames[i];
          const isBlack = note.includes('#');
          
          const pianoKey = document.createElement('div');
          pianoKey.className = `piano-key ${isBlack ? 'black' : 'white'}`;
          const midiNote = octave * 12 + i;
          pianoKey.dataset.note = midiNote;
          pianoKey.style.top = `${(127 - midiNote) * 20}px`;
          pianoKey.textContent = `${note}${octave}`;
          
          pianoRoll.appendChild(pianoKey);
        }
      }
    }
    
    // Refresh piano roll with notes - ENHANCED to better handle sequence selection
    async function refreshPianoRoll() {
      try {
        if (!state.sessionId) {
          return;
        }
        
        // Get session data
        const data = await callApi(`/sessions/${state.sessionId}`);
        if (!data) {
          log('Failed to get session data', 'error');
          return;
        }
        
        // Clear existing notes
        document.querySelectorAll('.piano-note').forEach(note => note.remove());
        
        // Extract notes for the current track
        let notes = [];
        
        if (data.session && data.session.tracks) {
          // Find the current track
          const currentTrack = data.session.tracks.find(track => track.id === state.currentSequenceId);
          
          if (currentTrack && currentTrack.notes) {
            notes = currentTrack.notes;
            log(`Found ${notes.length} notes in current sequence`, 'success');
          } else {
            // If no notes found in the current track, look for any track with notes
            const trackWithNotes = data.session.tracks.find(track => track.notes && track.notes.length > 0);
            if (trackWithNotes) {
              log(`No notes in current sequence, showing notes from ${trackWithNotes.name} instead`, 'info');
              notes = trackWithNotes.notes;
              // Auto-select this track
              await selectSequence(trackWithNotes.id);
            } else {
              log('No notes found in any sequence', 'info');
            }
          }
        }
        
        if (notes.length > 0) {
          notes.forEach(note => {
            const noteElement = document.createElement('div');
            
            // Select class based on channel or instrument
            const channel = note.channel || note.instrument || 0;
            if (channel === 9) {
              noteElement.className = 'piano-note drum-note';
            } else if (channel === 1 || channel === 32) {
              noteElement.className = 'piano-note bassline-note';
            } else {
              noteElement.className = 'piano-note';
            }
            
            // Position and size
            noteElement.style.top = `${(127 - note.pitch) * 20 + 1}px`;
            noteElement.style.left = `${note.startTime * 30 + 100}px`;
            noteElement.style.width = `${note.duration * 30}px`;
            
            // Add data for playback
            noteElement.dataset.pitch = note.pitch;
            noteElement.dataset.start = note.startTime;
            noteElement.dataset.duration = note.duration;
            noteElement.dataset.velocity = note.velocity || 100;
            noteElement.dataset.channel = note.channel || note.instrument || 0;
            
            // Add note name for better visibility
            noteElement.textContent = note.pitch;
            
            pianoRoll.appendChild(noteElement);
          });
          
          log(`Displayed ${notes.length} notes in piano roll`, 'success');
          
          // Update player status
          playBtn.disabled = false;
          stopBtn.disabled = false;
          playStatus.textContent = `${notes.length} notes ready to play`;
        } else {
          log('No notes to display', 'info');
          
          // Update player status
          playBtn.disabled = true;
          stopBtn.disabled = true;
          playStatus.textContent = 'Nothing to play';
        }
      } catch (error) {
        console.error('Error refreshing piano roll:', error);
        log(`Error refreshing piano roll: ${error.message}`, 'error');
      }
    }
    
    // Play the sequence
    function playSequence() {
      if (!state.audioContext) {
        initAudio();
      }
      
      if (state.isPlaying) {
        stopPlayback();
      }
      
      const notes = document.querySelectorAll('.piano-note');
      if (notes.length === 0) {
        updateStatus('No notes to play');
        return;
      }
      
      state.isPlaying = true;
      updateStatus('Playing...');
      playStatus.textContent = 'Playing...';
      
      const startTime = state.audioContext.currentTime;
      const tempo = 120; // beats per minute
      const secondsPerBeat = 60 / tempo;
      
      notes.forEach(noteElement => {
        // Skip drum notes for now (they sound strange)
        if (parseInt(noteElement.dataset.channel) === 9) {
          return;
        }
        
        const pitch = parseInt(noteElement.dataset.pitch);
        const noteStartTime = startTime + (parseFloat(noteElement.dataset.start) * secondsPerBeat);
        const noteDuration = parseFloat(noteElement.dataset.duration) * secondsPerBeat;
        const velocity = parseInt(noteElement.dataset.velocity) / 127;
        
        // Create oscillator
        const oscillator = state.audioContext.createOscillator();
        const gainNode = state.audioContext.createGain();
        
        // Configure oscillator based on channel
        const channel = parseInt(noteElement.dataset.channel);
        oscillator.type = (channel === 1 || channel === 32) ? 'triangle' : 'sine';
        oscillator.frequency.value = midiToFrequency(pitch);
        
        // Connect
        oscillator.connect(gainNode);
        gainNode.connect(state.audioContext.destination);
        
        // Set volume
        gainNode.gain.value = velocity * 0.2;
        
        // Schedule note
        oscillator.start(noteStartTime);
        oscillator.stop(noteStartTime + noteDuration);
        
        // Add visual feedback
        setTimeout(() => {
          noteElement.style.backgroundColor = 'yellow';
          setTimeout(() => {
            const channel = noteElement.dataset.channel;
            if (channel === '9') {
              noteElement.style.backgroundColor = '#db4437';
            } else if (channel === '1' || channel === '32') {
              noteElement.style.backgroundColor = '#0f9d58';
            } else {
              noteElement.style.backgroundColor = '#4285f4';
            }
          }, noteDuration * 1000);
        }, (noteStartTime - startTime) * 1000);
        
        // Save for cleanup
        state.oscillators.push(oscillator);
      });
      
      // Find the longest note to stop playback
      const longestDuration = Math.max(...Array.from(notes).map(note => 
        parseFloat(note.dataset.start) + parseFloat(note.dataset.duration)
      ));
      
      // Auto-stop at end
      setTimeout(() => {
        if (state.isPlaying) {
          stopPlayback();
        }
      }, longestDuration * secondsPerBeat * 1000);
    }
    
    // Stop playback
    function stopPlayback() {
      if (!state.isPlaying) return;
      
      // Stop all oscillators
      state.oscillators.forEach(osc => {
        try {
          osc.stop();
        } catch (e) {
          // Ignore errors for oscillators that are already stopped
        }
      });
      
      state.oscillators = [];
      state.isPlaying = false;
      
      updateStatus('Playback stopped');
      playStatus.textContent = `${state.noteCount} notes ready to play`;
    }
    
    // Convert MIDI note to frequency
    function midiToFrequency(note) {
      return 440 * Math.pow(2, (note - 69) / 12);
    }
    
    // Event listeners
    setupBtn.addEventListener('click', setup);
    createSequenceBtn.addEventListener('click', createSequence);
    newSequenceName.addEventListener('keypress', function(e) {
      if (e.key === 'Enter') {
        createSequence();
      }
    });
    chordBtn.addEventListener('click', generateChords);
    bassBtn.addEventListener('click', generateBass);
    drumBtn.addEventListener('click', generateDrums);
    clearBtn.addEventListener('click', clearNotes);
    playBtn.addEventListener('click', playSequence);
    stopBtn.addEventListener('click', stopPlayback);
    exportMidiBtn.addEventListener('click', exportMidiFile);
    exportJsonBtn.addEventListener('click', exportJson);
    importBtn.addEventListener('click', showImportArea);
    processImportBtn.addEventListener('click', processImport);
    copyJsonBtn.addEventListener('click', copyJsonToClipboard);
    saveJsonBtn.addEventListener('click', saveJsonToFile);
    fileInput.addEventListener('change', handleFileUpload);
    
    // Initialize
    updateStatus('Ready - click "Set Up" to begin');
    log('Interface loaded, click "Set Up" to begin', 'success');
  </script>
</body>
</html>
