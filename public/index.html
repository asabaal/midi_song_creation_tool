<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Super Simple MIDI Player</title>
  <style>
    body { font-family: Arial, sans-serif; max-width: 1000px; margin: 0 auto; padding: 20px; }
    h1, h2 { color: #333; }
    button { background: #4CAF50; color: white; border: none; padding: 10px 15px; 
             border-radius: 4px; cursor: pointer; margin: 5px; }
    button.blue { background: #2196F3; }
    button.red { background: #F44336; }
    button.purple { background: #9C27B0; }
    button.orange { background: #FF9800; }
    button:disabled { background: #cccccc; cursor: not-allowed; }
    .card { border: 1px solid #ddd; border-radius: 4px; padding: 15px; margin-bottom: 20px; }
    .controls { display: flex; gap: 10px; margin-bottom: 10px; flex-wrap: wrap; }
    #piano-roll { height: 400px; background: #f5f5f5; overflow: auto; position: relative; }
    .piano-key { position: absolute; height: 20px; border-bottom: 1px solid #ddd; display: flex;
                align-items: center; padding-left: 10px; font-size: 12px; width: 100px; }
    .piano-key.white { background: white; }
    .piano-key.black { background: #f8f8f8; }
    .piano-note { position: absolute; height: 18px; background: #4285f4; border-radius: 3px; opacity: 0.8; 
                 cursor: pointer; color: white; font-size: 10px; display: flex; align-items: center; 
                 justify-content: center; overflow: hidden; }
    .bassline-note { background: #0f9d58; }
    .drum-note { background: #db4437; }
    .status { padding: 10px; background: #f1f1f1; margin-top: 20px; border-radius: 4px; }
    .log { height: 100px; overflow: auto; background: #f1f1f1; padding: 10px; 
          font-family: monospace; margin-top: 10px; }
    .success { color: green; }
    .error { color: red; }
    textarea { width: 100%; height: 100px; margin-top: 10px; font-family: monospace; }
    .hidden { display: none; }
  </style>
</head>
<body>
  <h1>Super Simple MIDI Player</h1>
  <p>Create music with just a few clicks:</p>
  
  <div class="card">
    <h2>1. Create a Session and Sequence</h2>
    <div class="controls">
      <button id="setupBtn">Set Up (Create Session + Sequence)</button>
      <span id="setupStatus">Not set up yet</span>
    </div>
  </div>
  
  <div class="card">
    <h2>2. Generate Music</h2>
    <div class="controls">
      <button id="chordBtn" disabled>Add Chord Progression</button>
      <button id="bassBtn" class="blue" disabled>Add Bassline</button>
      <button id="drumBtn" class="blue" disabled>Add Drums</button>
      <button id="clearBtn" class="red" disabled>Clear Notes</button>
    </div>
  </div>
  
  <div class="card">
    <h2>3. Play Music</h2>
    <div class="controls">
      <button id="playBtn" disabled>▶️ Play</button>
      <button id="stopBtn" disabled>⏹️ Stop</button>
      <span id="playStatus">Nothing to play</span>
    </div>
  </div>

  <div class="card">
    <h2>4. Import/Export</h2>
    <div class="controls">
      <button id="exportBtn" class="purple" disabled>Export to MIDI</button>
      <button id="importBtn" class="orange" disabled>Import from MIDI</button>
    </div>
    <div id="exportArea" class="hidden">
      <p>Exported MIDI Data (JSON format):</p>
      <textarea id="exportText" readonly></textarea>
      <p>Save this JSON data or copy it to import later.</p>
    </div>
    <div id="importArea" class="hidden">
      <p>Paste MIDI Data (JSON format) to import:</p>
      <textarea id="importText"></textarea>
      <button id="processImportBtn" class="orange">Process Import</button>
    </div>
  </div>
  
  <div class="card">
    <h2>Piano Roll</h2>
    <div id="piano-roll"></div>
  </div>
  
  <div class="status">Status: Ready</div>
  <div class="log" id="log"></div>
  
  <script>
    // Global state
    let state = {
      sessionId: null,
      sequenceId: null,
      audioContext: null,
      isPlaying: false,
      oscillators: [],
      noteCount: 0
    };
    
    // DOM elements
    const setupStatus = document.getElementById('setupStatus');
    const playStatus = document.getElementById('playStatus');
    const pianoRoll = document.getElementById('piano-roll');
    const statusBar = document.querySelector('.status');
    const logElement = document.getElementById('log');
    const exportText = document.getElementById('exportText');
    const importText = document.getElementById('importText');
    const exportArea = document.getElementById('exportArea');
    const importArea = document.getElementById('importArea');
    
    // Buttons
    const setupBtn = document.getElementById('setupBtn');
    const chordBtn = document.getElementById('chordBtn');
    const bassBtn = document.getElementById('bassBtn');
    const drumBtn = document.getElementById('drumBtn');
    const clearBtn = document.getElementById('clearBtn');
    const playBtn = document.getElementById('playBtn');
    const stopBtn = document.getElementById('stopBtn');
    const exportBtn = document.getElementById('exportBtn');
    const importBtn = document.getElementById('importBtn');
    const processImportBtn = document.getElementById('processImportBtn');
    
    // Logging function
    function log(message, type = 'info') {
      console.log(message);
      const entry = document.createElement('div');
      entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
      entry.className = type;
      logElement.appendChild(entry);
      logElement.scrollTop = logElement.scrollHeight;
    }
    
    // Update status
    function updateStatus(message) {
      statusBar.textContent = 'Status: ' + message;
    }
    
    // API helper
    async function callApi(endpoint, method = 'GET', body = null) {
      try {
        const options = {
          method,
          headers: { 'Content-Type': 'application/json' }
        };

        if (body) {
          options.body = JSON.stringify(body);
        }

        log(`API Call: ${method} ${endpoint}`);
        const response = await fetch(`/api${endpoint}`, options);
        
        if (!response.ok) {
          const errorText = await response.text();
          log(`API error (${response.status}): ${errorText}`, 'error');
          return null;
        }
        
        const data = await response.json();

        if (!data.success) {
          log(`API Error: ${data.message}`, 'error');
          return null;
        }

        return data;
      } catch (error) {
        log(`Error: ${error.message}`, 'error');
        return null;
      }
    }
    
    // Initialize audio context
    function initAudio() {
      try {
        state.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        log('Audio initialized', 'success');
        return true;
      } catch (error) {
        log(`Audio initialization error: ${error.message}`, 'error');
        return false;
      }
    }
    
    // Setup (create session and sequence)
    async function setup() {
      // Create session
      const sessionData = await callApi('/sessions', 'POST', {});
      if (!sessionData) {
        log('Failed to create session', 'error');
        return false;
      }
      
      state.sessionId = sessionData.sessionId;
      log(`Session created: ${state.sessionId}`, 'success');
      
      // Create sequence
      const sequenceData = await callApi(`/sessions/${state.sessionId}/sequences`, 'POST', {
        name: 'My Music',
        tempo: 120,
        key: 'C major'
      });
      
      if (!sequenceData) {
        log('Failed to create sequence', 'error');
        return false;
      }
      
      state.sequenceId = sequenceData.sequenceId;
      log(`Sequence created: ${state.sequenceId}`, 'success');
      
      // Update UI
      setupStatus.textContent = `Ready (Session: ${state.sessionId.substring(0, 8)}...)`;
      chordBtn.disabled = false;
      bassBtn.disabled = false;
      drumBtn.disabled = false;
      clearBtn.disabled = false;
      exportBtn.disabled = false;
      importBtn.disabled = false;
      
      // Get piano roll ready
      initPianoRoll();
      
      return true;
    }
    
    // Generate chord progression
    async function generateChords() {
      if (!state.sessionId || !state.sequenceId) {
        log('Set up session first', 'error');
        return;
      }
      
      updateStatus('Generating chord progression...');
      
      const data = await callApi(`/sessions/${state.sessionId}/patterns/chord-progression`, 'POST', {
        key: 'C',
        progressionName: '1-4-5',
        scaleType: 'major',
        octave: 4,
        rhythmPattern: [4]
      });
      
      if (!data) {
        updateStatus('Failed to generate chord progression');
        return;
      }
      
      state.noteCount = data.noteCount;
      updateStatus(`Generated chord progression with ${data.noteCount} notes`);
      log(`Added ${data.noteCount} notes`, 'success');
      
      // Refresh piano roll
      refreshPianoRoll();
      
      // Enable play button
      playBtn.disabled = false;
      stopBtn.disabled = false;
      playStatus.textContent = `${state.noteCount} notes ready to play`;
    }
    
    // Generate bassline
    async function generateBass() {
      if (!state.sessionId || !state.sequenceId) {
        log('Set up session first', 'error');
        return;
      }
      
      updateStatus('Generating bassline...');
      
      const data = await callApi(`/sessions/${state.sessionId}/patterns/bassline`, 'POST', {
        key: 'C',
        progressionName: '1-4-5',
        scaleType: 'major',
        octave: 3,
        rhythmPattern: [1, 0.5, 0.5]
      });
      
      if (!data) {
        updateStatus('Failed to generate bassline');
        return;
      }
      
      state.noteCount = data.noteCount;
      updateStatus(`Added bassline (total: ${data.noteCount} notes)`);
      log(`Sequence now has ${data.noteCount} notes`, 'success');
      
      // Refresh piano roll
      refreshPianoRoll();
      
      // Enable play button
      playBtn.disabled = false;
      stopBtn.disabled = false;
      playStatus.textContent = `${state.noteCount} notes ready to play`;
    }
    
    // Generate drums
    async function generateDrums() {
      if (!state.sessionId || !state.sequenceId) {
        log('Set up session first', 'error');
        return;
      }
      
      updateStatus('Generating drum pattern...');
      
      const data = await callApi(`/sessions/${state.sessionId}/patterns/drums`, 'POST', {
        patternType: 'basic',
        measures: 2
      });
      
      if (!data) {
        updateStatus('Failed to generate drum pattern');
        return;
      }
      
      state.noteCount = data.noteCount;
      updateStatus(`Added drums (total: ${data.noteCount} notes)`);
      log(`Sequence now has ${data.noteCount} notes`, 'success');
      
      // Refresh piano roll
      refreshPianoRoll();
      
      // Enable play button
      playBtn.disabled = false;
      stopBtn.disabled = false;
      playStatus.textContent = `${state.noteCount} notes ready to play`;
    }
    
    // Clear all notes
    async function clearNotes() {
      if (!state.sessionId || !state.sequenceId) {
        log('Set up session first', 'error');
        return;
      }
      
      updateStatus('Clearing notes...');
      
      const data = await callApi(`/sessions/${state.sessionId}/notes`, 'DELETE');
      
      if (!data) {
        updateStatus('Failed to clear notes');
        return;
      }
      
      state.noteCount = 0;
      updateStatus('All notes cleared');
      log('Notes cleared', 'success');
      
      // Refresh piano roll
      refreshPianoRoll();
      
      // Disable play button
      playBtn.disabled = true;
      stopBtn.disabled = true;
      playStatus.textContent = 'Nothing to play';
    }
    
    // Export MIDI
    async function exportMidi() {
      if (!state.sessionId || !state.sequenceId) {
        log('Set up session first', 'error');
        return;
      }
      
      updateStatus('Exporting MIDI data...');
      
      const data = await callApi(`/sessions/${state.sessionId}/export`, 'GET');
      
      if (!data) {
        updateStatus('Failed to export MIDI data');
        return;
      }
      
      // Show exported data in textarea
      exportText.value = data.data;
      exportArea.classList.remove('hidden');
      importArea.classList.add('hidden');
      
      updateStatus(`Exported ${data.noteCount} notes to MIDI format`);
      log(`Exported sequence ${data.sequenceId}`, 'success');
    }
    
    // Show import area
    function showImportArea() {
      if (!state.sessionId) {
        log('Set up session first', 'error');
        return;
      }
      
      exportArea.classList.add('hidden');
      importArea.classList.remove('hidden');
      importText.value = '';
      importText.focus();
      
      updateStatus('Ready to import MIDI data');
    }
    
    // Process import
    async function processImport() {
      if (!state.sessionId) {
        log('Set up session first', 'error');
        return;
      }
      
      const midiData = importText.value.trim();
      if (!midiData) {
        log('No MIDI data to import', 'error');
        return;
      }
      
      updateStatus('Importing MIDI data...');
      
      const data = await callApi(`/sessions/${state.sessionId}/import`, 'POST', {
        midiData: midiData,
        name: 'Imported Sequence'
      });
      
      if (!data) {
        updateStatus('Failed to import MIDI data');
        return;
      }
      
      state.sequenceId = data.sequenceId;
      state.noteCount = data.sequence.noteCount;
      
      updateStatus(`Imported ${data.sequence.noteCount} notes successfully`);
      log(`Imported sequence ${data.sequenceId}`, 'success');
      
      // Hide import area
      importArea.classList.add('hidden');
      
      // Refresh piano roll and update UI
      refreshPianoRoll();
      
      // Enable play button if notes were imported
      playBtn.disabled = data.sequence.noteCount === 0;
      stopBtn.disabled = data.sequence.noteCount === 0;
      playStatus.textContent = data.sequence.noteCount > 0 ? 
        `${data.sequence.noteCount} notes ready to play` : 'Nothing to play';
    }
    
    // Initialize piano roll
    function initPianoRoll() {
      pianoRoll.innerHTML = '';
      
      // Create piano keys (just one octave for simplicity)
      const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
      
      for (let octave = 5; octave >= 2; octave--) {
        for (let i = 11; i >= 0; i--) {
          const note = noteNames[i];
          const isBlack = note.includes('#');
          
          const pianoKey = document.createElement('div');
          pianoKey.className = `piano-key ${isBlack ? 'black' : 'white'}`;
          const midiNote = octave * 12 + i;
          pianoKey.dataset.note = midiNote;
          pianoKey.style.top = `${(127 - midiNote) * 20}px`;
          pianoKey.textContent = `${note}${octave}`;
          
          pianoRoll.appendChild(pianoKey);
        }
      }
    }
    
    // Refresh piano roll with notes
    async function refreshPianoRoll() {
      // Get sequence data
      const data = await callApi(`/sessions/${state.sessionId}/sequences/${state.sequenceId}`);
      if (!data) {
        log('Failed to get sequence data', 'error');
        return;
      }
      
      // Clear existing notes
      document.querySelectorAll('.piano-note').forEach(note => note.remove());
      
      // Add notes
      if (data.sequence.notes && data.sequence.notes.length > 0) {
        data.sequence.notes.forEach(note => {
          const noteElement = document.createElement('div');
          
          // Select class based on channel
          if (note.channel === 9) {
            noteElement.className = 'piano-note drum-note';
          } else if (note.channel === 1) {
            noteElement.className = 'piano-note bassline-note';
          } else {
            noteElement.className = 'piano-note';
          }
          
          // Position and size
          noteElement.style.top = `${(127 - note.pitch) * 20 + 1}px`;
          noteElement.style.left = `${note.startTime * 30 + 100}px`;
          noteElement.style.width = `${note.duration * 30}px`;
          
          // Add data for playback
          noteElement.dataset.pitch = note.pitch;
          noteElement.dataset.start = note.startTime;
          noteElement.dataset.duration = note.duration;
          noteElement.dataset.velocity = note.velocity;
          noteElement.dataset.channel = note.channel;
          
          // Add note name for better visibility
          noteElement.textContent = note.pitch;
          
          pianoRoll.appendChild(noteElement);
        });
        
        log(`Displayed ${data.sequence.notes.length} notes in piano roll`, 'success');
      }
    }
    
    // Play the sequence
    function playSequence() {
      if (!state.audioContext) {
        initAudio();
      }
      
      if (state.isPlaying) {
        stopPlayback();
      }
      
      // Refresh notes to make sure we have the latest
      refreshPianoRoll().then(() => {
        const notes = document.querySelectorAll('.piano-note');
        if (notes.length === 0) {
          updateStatus('No notes to play');
          return;
        }
        
        state.isPlaying = true;
        updateStatus('Playing...');
        playStatus.textContent = 'Playing...';
        
        const startTime = state.audioContext.currentTime;
        const tempo = 120; // beats per minute
        const secondsPerBeat = 60 / tempo;
        
        notes.forEach(noteElement => {
          // Skip drum notes for now (they sound strange)
          if (parseInt(noteElement.dataset.channel) === 9) {
            return;
          }
          
          const pitch = parseInt(noteElement.dataset.pitch);
          const noteStartTime = startTime + (parseFloat(noteElement.dataset.start) * secondsPerBeat);
          const noteDuration = parseFloat(noteElement.dataset.duration) * secondsPerBeat;
          const velocity = parseInt(noteElement.dataset.velocity) / 127;
          
          // Create oscillator
          const oscillator = state.audioContext.createOscillator();
          const gainNode = state.audioContext.createGain();
          
          // Configure oscillator
          oscillator.type = parseInt(noteElement.dataset.channel) === 1 ? 'triangle' : 'sine';
          oscillator.frequency.value = midiToFrequency(pitch);
          
          // Connect
          oscillator.connect(gainNode);
          gainNode.connect(state.audioContext.destination);
          
          // Set volume
          gainNode.gain.value = velocity * 0.2;
          
          // Schedule note
          oscillator.start(noteStartTime);
          oscillator.stop(noteStartTime + noteDuration);
          
          // Add visual feedback
          setTimeout(() => {
            noteElement.style.backgroundColor = 'yellow';
            setTimeout(() => {
              if (noteElement.dataset.channel === '9') {
                noteElement.style.backgroundColor = '#db4437';
              } else if (noteElement.dataset.channel === '1') {
                noteElement.style.backgroundColor = '#0f9d58';
              } else {
                noteElement.style.backgroundColor = '#4285f4';
              }
            }, noteDuration * 1000);
          }, (noteStartTime - startTime) * 1000);
          
          // Save for cleanup
          state.oscillators.push(oscillator);
        });
        
        // Find the longest note to stop playback
        const longestDuration = Math.max(...Array.from(notes).map(note => 
          parseFloat(note.dataset.start) + parseFloat(note.dataset.duration)
        ));
        
        // Auto-stop at end
        setTimeout(() => {
          if (state.isPlaying) {
            stopPlayback();
          }
        }, longestDuration * secondsPerBeat * 1000);
      });
    }
    
    // Stop playback
    function stopPlayback() {
      if (!state.isPlaying) return;
      
      // Stop all oscillators
      state.oscillators.forEach(osc => {
        try {
          osc.stop();
        } catch (e) {
          // Ignore errors for oscillators that are already stopped
        }
      });
      
      state.oscillators = [];
      state.isPlaying = false;
      
      updateStatus('Playback stopped');
      playStatus.textContent = `${state.noteCount} notes ready to play`;
    }
    
    // Convert MIDI note to frequency
    function midiToFrequency(note) {
      return 440 * Math.pow(2, (note - 69) / 12);
    }
    
    // Event listeners
    setupBtn.addEventListener('click', setup);
    chordBtn.addEventListener('click', generateChords);
    bassBtn.addEventListener('click', generateBass);
    drumBtn.addEventListener('click', generateDrums);
    clearBtn.addEventListener('click', clearNotes);
    playBtn.addEventListener('click', playSequence);
    stopBtn.addEventListener('click', stopPlayback);
    exportBtn.addEventListener('click', exportMidi);
    importBtn.addEventListener('click', showImportArea);
    processImportBtn.addEventListener('click', processImport);
    
    // Initialize
    updateStatus('Ready - click "Set Up" to begin');
    log('Interface loaded, click "Set Up" to begin', 'success');
  </script>
</body>
</html>
